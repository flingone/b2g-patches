diff --git a/gecko/widget/gonk/libdisplay/GonkDisplayJB.cpp b/gecko/widget/gonk/libdisplay/GonkDisplayJB.cpp
index 7b540f9..8d71e9d 100644
--- a/gecko/widget/gonk/libdisplay/GonkDisplayJB.cpp
+++ b/gecko/widget/gonk/libdisplay/GonkDisplayJB.cpp
@@ -100,83 +100,81 @@ GonkDisplayJB::GonkDisplayJB()
     err = hw_get_module(POWER_HARDWARE_MODULE_ID,
                                            (hw_module_t const**)&mPowerModule);
     if (!err)
         mPowerModule->init(mPowerModule);
     ALOGW_IF(err, "Couldn't load %s module (%s)", POWER_HARDWARE_MODULE_ID, strerror(-err));
 
     mAlloc = new GraphicBufferAlloc();
 
     status_t error;
+    uint32_t usage = GRALLOC_USAGE_HW_FB | GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_COMPOSER;
+    mBootAnimBuffer = mAlloc->createGraphicBuffer(mWidth, mHeight, surfaceformat, usage, &error);
+    if (error != NO_ERROR || !mBootAnimBuffer.get()) {
+        ALOGI("Trying to create BRGA format framebuffer");
+        surfaceformat = HAL_PIXEL_FORMAT_BGRA_8888;
+        mBootAnimBuffer = mAlloc->createGraphicBuffer(mWidth, mHeight, surfaceformat, usage, &error);
+    }
 
 #if ANDROID_VERSION >= 19
     sp<BufferQueue> bq = new BufferQueue(mAlloc);
 #else
     sp<BufferQueue> bq = new BufferQueue(true, mAlloc);
 #endif
     mFBSurface = new FramebufferSurface(0, mWidth, mHeight, surfaceformat, bq);
 
 #if ANDROID_VERSION == 17
     sp<SurfaceTextureClient> stc = new SurfaceTextureClient(static_cast<sp<ISurfaceTexture> >(mFBSurface->getBufferQueue()));
 #else
     sp<Surface> stc = new Surface(static_cast<sp<IGraphicBufferProducer> >(bq));
 #endif
     mSTClient = stc;
-    mSTClient->perform(mSTClient.get(), NATIVE_WINDOW_SET_BUFFER_COUNT, 2);
-    mSTClient->perform(mSTClient.get(), NATIVE_WINDOW_SET_USAGE, GRALLOC_USAGE_HW_FB | GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_COMPOSER);
 
     mList = (hwc_display_contents_1_t *)malloc(sizeof(*mList) + (sizeof(hwc_layer_1_t)*2));
     if (mHwc)
         mHwc->blank(mHwc, HWC_DISPLAY_PRIMARY, 0);
 
-    if (error == NO_ERROR) {
+    if (error == NO_ERROR && mBootAnimBuffer.get()) {
         ALOGI("Starting bootanimation with (%d) format framebuffer", surfaceformat);
         StartBootAnimation();
     } else
         ALOGW("Couldn't show bootanimation (%s)", strerror(-error));
 }
 
 GonkDisplayJB::~GonkDisplayJB()
 {
     if (mHwc)
         hwc_close_1(mHwc);
     if (mFBDevice)
         framebuffer_close(mFBDevice);
     free(mList);
 }
 
 ANativeWindow*
 GonkDisplayJB::GetNativeWindow()
 {
-    StopBootAnimation();
     return mSTClient.get();
 }
 
 void
 GonkDisplayJB::SetEnabled(bool enabled)
 {
     if (enabled) {
         autosuspend_disable();
         mPowerModule->setInteractive(mPowerModule, true);
     }
 
-    if (!enabled && mEnabledCallback) {
-        mEnabledCallback(enabled);
-    }
-
-    if (mHwc && mHwc->blank) {
+    if (mHwc)
         mHwc->blank(mHwc, HWC_DISPLAY_PRIMARY, !enabled);
-    } else if (mFBDevice && mFBDevice->enableScreen) {
+    else if (mFBDevice->enableScreen)
         mFBDevice->enableScreen(mFBDevice, enabled);
-    }
 
-    if (enabled && mEnabledCallback) {
+    if (mEnabledCallback)
         mEnabledCallback(enabled);
-    }
 
     if (!enabled) {
         autosuspend_enable();
         mPowerModule->setInteractive(mPowerModule, false);
     }
 }
 
 void
 GonkDisplayJB::OnEnabled(OnEnabledCallbackType callback)
@@ -193,18 +191,21 @@ GonkDisplayJB::GetHWCDevice()
 void*
 GonkDisplayJB::GetFBSurface()
 {
     return mFBSurface.get();
 }
 
 bool
 GonkDisplayJB::SwapBuffers(EGLDisplay dpy, EGLSurface sur)
 {
+    StopBootAnimation();
+    mBootAnimBuffer = nullptr;
+
     // Should be called when composition rendering is complete for a frame.
     // Only HWC v1.0 needs this call.
     // HWC > v1.0 case, do not call compositionComplete().
     // mFBDevice is present only when HWC is v1.0.
     if (mFBDevice && mFBDevice->compositionComplete) {
         mFBDevice->compositionComplete(mFBDevice);
     }
 
 #if ANDROID_VERSION == 17
@@ -222,86 +223,84 @@ bool
 GonkDisplayJB::Post(buffer_handle_t buf, int fence)
 {
     if (!mHwc) {
         if (fence >= 0)
             close(fence);
         return !mFBDevice->post(mFBDevice, buf);
     }
 
     hwc_display_contents_1_t *displays[HWC_NUM_DISPLAY_TYPES] = {NULL};
-    const hwc_rect_t r = { 0, 0, static_cast<int>(mWidth), static_cast<int>(mHeight) };
+    const hwc_rect_t r = { 0, 0, mWidth, mHeight };
     displays[HWC_DISPLAY_PRIMARY] = mList;
     mList->retireFenceFd = -1;
     mList->numHwLayers = 2;
     mList->flags = HWC_GEOMETRY_CHANGED;
     mList->hwLayers[0].compositionType = HWC_FRAMEBUFFER;
     mList->hwLayers[0].hints = 0;
     /* Skip this layer so the hwc module doesn't complain about null handles */
     mList->hwLayers[0].flags = HWC_SKIP_LAYER;
     mList->hwLayers[0].backgroundColor = {0};
     mList->hwLayers[0].acquireFenceFd = -1;
     mList->hwLayers[0].releaseFenceFd = -1;
     /* hwc module checks displayFrame even though it shouldn't */
     mList->hwLayers[0].displayFrame = r;
     mList->hwLayers[1].compositionType = HWC_FRAMEBUFFER_TARGET;
     mList->hwLayers[1].hints = 0;
     mList->hwLayers[1].flags = 0;
     mList->hwLayers[1].handle = buf;
     mList->hwLayers[1].transform = 0;
-    mList->hwLayers[1].blending = HWC_BLENDING_NONE;
+    mList->hwLayers[1].blending = HWC_BLENDING_PREMULT;
 #if ANDROID_VERSION >= 19
     if (mHwc->common.version >= HWC_DEVICE_API_VERSION_1_3) {
         mList->hwLayers[1].sourceCropf.left = 0;
         mList->hwLayers[1].sourceCropf.top = 0;
         mList->hwLayers[1].sourceCropf.right = mWidth;
         mList->hwLayers[1].sourceCropf.bottom = mHeight;
     } else {
         mList->hwLayers[1].sourceCrop = r;
     }
 #else
     mList->hwLayers[1].sourceCrop = r;
 #endif
     mList->hwLayers[1].displayFrame = r;
     mList->hwLayers[1].visibleRegionScreen.numRects = 1;
     mList->hwLayers[1].visibleRegionScreen.rects = &mList->hwLayers[1].displayFrame;
     mList->hwLayers[1].acquireFenceFd = fence;
     mList->hwLayers[1].releaseFenceFd = -1;
-#if ANDROID_VERSION >= 18
+#if ANDROID_VERSION == 18
     mList->hwLayers[1].planeAlpha = 0xFF;
 #endif
     mHwc->prepare(mHwc, HWC_NUM_DISPLAY_TYPES, displays);
     int err = mHwc->set(mHwc, HWC_NUM_DISPLAY_TYPES, displays);
     mFBSurface->setReleaseFenceFd(mList->hwLayers[1].releaseFenceFd);
     if (mList->retireFenceFd >= 0)
         close(mList->retireFenceFd);
     return !err;
 }
 
 ANativeWindowBuffer*
 GonkDisplayJB::DequeueBuffer()
 {
-    ANativeWindowBuffer *buf;
-    mSTClient->dequeueBuffer(mSTClient.get(), &buf, &mFence);
-    return buf;
+    return static_cast<ANativeWindowBuffer*>(mBootAnimBuffer.get());
 }
 
 bool
 GonkDisplayJB::QueueBuffer(ANativeWindowBuffer* buf)
 {
     bool success = Post(buf->handle, -1);
-    int error = mSTClient->queueBuffer(mSTClient.get(), buf, mFence);
-
-    return error == 0 && success;
+    return success;
 }
 
 void
 GonkDisplayJB::UpdateFBSurface(EGLDisplay dpy, EGLSurface sur)
 {
+    StopBootAnimation();
+    mBootAnimBuffer = nullptr;
     eglSwapBuffers(dpy, sur);
 }
 
 void
 GonkDisplayJB::SetFBReleaseFd(int fd)
 {
     mFBSurface->setReleaseFenceFd(fd);
 }
 
diff --git a/gecko/widget/gonk/libdisplay/GonkDisplayJB.h b/gecko/widget/gonk/libdisplay/GonkDisplayJB.h
index ad73562..c09ba75 100644
--- a/gecko/widget/gonk/libdisplay/GonkDisplayJB.h
+++ b/gecko/widget/gonk/libdisplay/GonkDisplayJB.h
@@ -57,19 +57,19 @@ public:
 private:
     hw_module_t const*        mModule;
     hw_module_t const*        mFBModule;
     hwc_composer_device_1_t*  mHwc;
     framebuffer_device_t*     mFBDevice;
     power_module_t*           mPowerModule;
     android::sp<android::FramebufferSurface> mFBSurface;
     android::sp<ANativeWindow> mSTClient;
     android::sp<android::IGraphicBufferAlloc> mAlloc;
-    int mFence;
+    android::sp<android::GraphicBuffer> mBootAnimBuffer;
     hwc_display_contents_1_t* mList;
     uint32_t mWidth;
     uint32_t mHeight;
     OnEnabledCallbackType mEnabledCallback;
 };
 
 }
 
 #endif /* GONKDISPLAYJB_H */
